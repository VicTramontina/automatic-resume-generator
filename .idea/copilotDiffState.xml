<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README_NEW.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README_NEW.md" />
              <option name="updatedContent" value="# Currículo Automático&#10;&#10;Este projeto automatiza a busca de vagas remotas, a personalização de um currículo em LaTeX e a geração de PDFs específicos para cada vaga encontrada. O fluxo geral é:&#10;&#10;1. **Coletar vagas** definidas em `config/job_config.yaml`.&#10;2. **Analisar** cada vaga com a API do Gemini para adaptar o currículo.&#10;3. **Gerar saída** em `outputs/` contendo um resumo (`job.md`) e o PDF do currículo ajustado para cada vaga.&#10;&#10;## Organização do projeto&#10;&#10;```&#10;├── config/          # Arquivos de configuração&#10;│   └── job_config.yaml&#10;├── latex/           # Modelo base do currículo em LaTeX&#10;├── outputs/         # Resultados gerados (um diretório por vaga)&#10;├── scripts/         # Scripts Python de automação&#10;└── Makefile         # Alvos para instalação, lint e execução&#10;```&#10;&#10;## Usando o Makefile&#10;&#10;```bash&#10;make setup   # cria ambiente virtual e instala dependências&#10;make lint    # verifica sintaxe dos scripts Python&#10;make run     # roda a pipeline completa&#10;make clean   # remove ambiente virtual e saídas geradas&#10;```&#10;&#10;Para personalizar o currículo, defina a variável de ambiente `GEMINI_API_KEY` com sua chave da API do Gemini antes de executar `make run`.&#10;&#10;## Funcionalidades Avançadas de Web Scraping&#10;&#10;### 1. Extração de Páginas Individuais de Vagas&#10;&#10;O sistema agora pode seguir links das vagas para extrair informações mais detalhadas das páginas individuais.&#10;&#10;### 2. Navegação por Páginas (Paginação)&#10;&#10;O sistema suporta três tipos de paginação:&#10;&#10;- **`next_button`**: Segue botões &quot;próxima página&quot; até não existir mais&#10;- **`numbered_links`**: Extrai links numerados de paginação  &#10;- **`url_pattern`**: Gera URLs baseado em um padrão (ex: `?page={page}`)&#10;&#10;### 3. Melhorias de Robustez&#10;&#10;- Headers de User-Agent realistas para evitar bloqueios&#10;- Tratamento de erros que permite continuar mesmo se algumas páginas falharem&#10;- Logs detalhados do progresso do scraping&#10;- Rate limiting automático entre requisições (1s entre páginas, 0.5s entre vagas)&#10;&#10;## Configuração das vagas (`job_config.yaml`)&#10;&#10;O arquivo `config/job_config.yaml` controla tanto o que será buscado quanto os filtros aplicados às vagas. Os principais parâmetros são:&#10;&#10;- `skills`: lista de palavras-chave que devem aparecer na vaga. Se nenhuma estiver presente, a vaga é ignorada.&#10;- `salary`:&#10;  - `usd`: salário mínimo em dólares (USD).&#10;  - `brl`: salário mínimo em reais (BRL).&#10;- `sites`: lista de sites a serem raspados. Cada site contém:&#10;  - `name`: nome do site.&#10;  - `url`: endereço da página de vagas.&#10;  - `job_selector`: seletor CSS que identifica cada card de vaga na página.&#10;  - `fields`: mapeamento de campos desejados para seletores CSS relativos ao card:&#10;    - `title`: título da vaga&#10;    - `company`: nome da empresa&#10;    - `link`: **OBRIGATÓRIO** - link para a página individual da vaga&#10;  - `detail_fields`: campos extraídos da página individual da vaga:&#10;    - `description`: descrição completa&#10;    - `salary`: informações de salário&#10;    - `skills`: tecnologias/habilidades&#10;    - `requirements`: requisitos&#10;    - `benefits`: benefícios&#10;  - `pagination`: configuração para navegar por múltiplas páginas:&#10;    - `type`: tipo de paginação (`next_button`, `numbered_links`, ou `url_pattern`)&#10;    - `max_pages`: máximo de páginas a percorrer&#10;    - Para `next_button`: `next_selector` (seletor do botão próxima)&#10;    - Para `numbered_links`: `links_selector` (seletor dos links de página)&#10;    - Para `url_pattern`: `url_pattern` (padrão da URL com `{page}`)&#10;&#10;### Exemplo de Configuração Completa&#10;&#10;```yaml&#10;skills:&#10;  - Python&#10;  - JavaScript&#10;  - Docker&#10;salary:&#10;  usd: 3000&#10;  brl: 6000&#10;&#10;sites:&#10;  - name: &quot;Remotar&quot;&#10;    url: &quot;https://remotar.com.br/search/jobs?q=desenvolvedor&quot;&#10;    job_selector: &quot;div.job-card&quot;&#10;    &#10;    # Campos básicos da listagem&#10;    fields:&#10;      title: &quot;h2&quot;&#10;      company: &quot;.company&quot;&#10;      link: &quot;a&quot;  # Link para página individual&#10;    &#10;    # Campos detalhados da página individual&#10;    detail_fields:&#10;      description: &quot;.job-description&quot;&#10;      salary: &quot;.salary-info&quot;&#10;      skills: &quot;.required-skills .tag&quot;&#10;      requirements: &quot;.requirements&quot;&#10;      benefits: &quot;.benefits&quot;&#10;    &#10;    # Configuração de paginação&#10;    pagination:&#10;      type: &quot;next_button&quot;&#10;      next_selector: &quot;.pagination .next&quot;&#10;      max_pages: 5&#10;```&#10;&#10;### Tipos de Paginação&#10;&#10;#### Botão &quot;Próxima&quot;&#10;```yaml&#10;pagination:&#10;  type: &quot;next_button&quot;&#10;  next_selector: &quot;.pagination .next&quot;&#10;  max_pages: 5&#10;```&#10;&#10;#### Links Numerados&#10;```yaml&#10;pagination:&#10;  type: &quot;numbered_links&quot;&#10;  links_selector: &quot;.pagination a&quot;&#10;  max_pages: 10&#10;```&#10;&#10;#### Padrão de URL&#10;```yaml&#10;pagination:&#10;  type: &quot;url_pattern&quot;&#10;  url_pattern: &quot;https://site.com/jobs?page={page}&quot;&#10;  max_pages: 5&#10;```&#10;&#10;Adapte estes campos conforme a estrutura HTML do site que deseja consultar.&#10;&#10;## Saídas&#10;&#10;Para cada vaga aprovada pelos filtros, é criado um diretório `outputs/job_N/` contendo:&#10;&#10;- `job.md`: resumo em Markdown com os dados coletados.&#10;- `resume.tex`: currículo ajustado em LaTeX.&#10;- `resume.pdf`: currículo compilado.&#10;&#10;Assim, você obtém um PDF personalizado para cada vaga remota filtrada.&#10;&#10;## Logs e Monitoramento&#10;&#10;O sistema fornece logs detalhados durante a execução:&#10;&#10;```&#10;Scraping Remotar...&#10;Found 2 additional pages to scrape&#10;Scraping page: https://remotar.com.br/search/jobs?q=desenvolvedor&#10;Found 10 job listings on this page&#10;Scraping details for: Desenvolvedor Python Sênior&#10;Scraping details for: Desenvolvedor Frontend React&#10;...&#10;Total jobs found: 25&#10;```&#10;&#10;## Dicas para Configuração&#10;&#10;1. **Teste os seletores**: Use as ferramentas de desenvolvedor do navegador para testar os seletores CSS&#10;2. **URLs relativas**: O sistema automaticamente converte URLs relativas em absolutas&#10;3. **Campos opcionais**: Se um campo não for encontrado, será definido como `None`&#10;4. **Paginação cautelosa**: Comece com `max_pages` baixo para testar&#10;5. **Rate limiting**: O sistema já inclui delays automáticos para ser respeitoso com os servidores" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SCRAPING_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SCRAPING_GUIDE.md" />
              <option name="updatedContent" value="# Guia de Web Scraping Avançado&#10;&#10;Este guia explica como usar as funcionalidades avançadas do web scraping implementadas no projeto.&#10;&#10;## Funcionalidades Implementadas&#10;&#10;### 1. Extração de Páginas Individuais de Vagas&#10;&#10;O sistema agora pode seguir links das vagas para extrair informações mais detalhadas das páginas individuais.&#10;&#10;#### Como Configurar:&#10;&#10;```yaml&#10;sites:&#10;  - name: &quot;Nome do Site&quot;&#10;    url: &quot;URL da página de listagem&quot;&#10;    job_selector: &quot;seletor CSS para cada vaga&quot;&#10;    fields:&#10;      title: &quot;seletor para título&quot;&#10;      company: &quot;seletor para empresa&quot;&#10;      link: &quot;seletor para o link da vaga&quot;  # IMPORTANTE: Campo obrigatório&#10;    detail_fields:  # Campos extraídos da página individual&#10;      description: &quot;seletor para descrição completa&quot;&#10;      salary: &quot;seletor para salário&quot;&#10;      skills: &quot;seletor para skills&quot;&#10;      requirements: &quot;seletor para requisitos&quot;&#10;      benefits: &quot;seletor para benefícios&quot;&#10;```&#10;&#10;### 2. Navegação por Páginas (Paginação)&#10;&#10;O sistema suporta três tipos de paginação:&#10;&#10;#### Tipo 1: Botão &quot;Próxima&quot;&#10;```yaml&#10;pagination:&#10;  type: &quot;next_button&quot;&#10;  next_selector: &quot;.pagination .next&quot;  # Seletor do botão &quot;próxima&quot;&#10;  max_pages: 5  # Máximo de páginas a percorrer&#10;```&#10;&#10;#### Tipo 2: Links Numerados&#10;```yaml&#10;pagination:&#10;  type: &quot;numbered_links&quot;&#10;  links_selector: &quot;.pagination a&quot;  # Seletor dos links de página&#10;  max_pages: 10&#10;```&#10;&#10;#### Tipo 3: Padrão de URL&#10;```yaml&#10;pagination:&#10;  type: &quot;url_pattern&quot;&#10;  url_pattern: &quot;https://site.com/jobs?page={page}&quot;  # {page} será substituído&#10;  max_pages: 5&#10;```&#10;&#10;## Exemplo de Configuração Completa&#10;&#10;```yaml&#10;skills:&#10;  - Python&#10;  - JavaScript&#10;  - Docker&#10;salary:&#10;  usd: 3000&#10;  brl: 6000&#10;&#10;sites:&#10;  - name: &quot;Site Exemplo&quot;&#10;    url: &quot;https://exemplo.com/vagas&quot;&#10;    job_selector: &quot;.vaga-card&quot;&#10;    &#10;    # Campos básicos da listagem&#10;    fields:&#10;      title: &quot;h2.titulo&quot;&#10;      company: &quot;.empresa&quot;&#10;      link: &quot;a.ver-mais&quot;  # Link para página individual&#10;    &#10;    # Campos detalhados da página individual&#10;    detail_fields:&#10;      description: &quot;.descricao-completa&quot;&#10;      salary: &quot;.salario&quot;&#10;      skills: &quot;.tecnologias .tag&quot;&#10;      requirements: &quot;.requisitos&quot;&#10;      benefits: &quot;.beneficios&quot;&#10;    &#10;    # Configuração de paginação&#10;    pagination:&#10;      type: &quot;next_button&quot;&#10;      next_selector: &quot;.proxima-pagina&quot;&#10;      max_pages: 3&#10;```&#10;&#10;## Funcionalidades de Segurança&#10;&#10;- **Rate Limiting**: Delay automático entre requisições (1 segundo entre páginas, 0.5 segundo entre vagas individuais)&#10;- **User-Agent**: Headers realistas para evitar bloqueios&#10;- **Error Handling**: Tratamento de erros para continuar o scraping mesmo se algumas páginas falharem&#10;- **Timeout**: Timeout de 30 segundos por requisição&#10;&#10;## Logs e Monitoramento&#10;&#10;O sistema agora fornece logs detalhados:&#10;- Número de páginas encontradas&#10;- Progresso do scraping por página&#10;- Erros encontrados&#10;- Total de vagas coletadas&#10;&#10;## Dicas para Configuração&#10;&#10;1. **Teste os seletores**: Use as ferramentas de desenvolvedor do navegador para testar os seletores CSS&#10;2. **URLs relativas**: O sistema automaticamente converte URLs relativas em absolutas&#10;3. **Campos opcionais**: Se um campo não for encontrado, será definido como `None`&#10;4. **Paginação cautelosa**: Comece com `max_pages` baixo para testar&#10;&#10;## Exemplo de Execução&#10;&#10;```bash&#10;cd scripts&#10;python scrape_jobs.py --config ../config/job_config.yaml&#10;```&#10;&#10;O output mostrará o progresso:&#10;```&#10;Scraping Remotar...&#10;Found 2 additional pages to scrape&#10;Scraping page: https://remotar.com.br/search/jobs?q=desenvolvedor&#10;Found 10 job listings on this page&#10;Scraping details for: Desenvolvedor Python Sênior&#10;Scraping details for: Desenvolvedor Frontend React&#10;...&#10;Total jobs found: 25&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/latex/resume.tex">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/latex/resume.tex" />
              <option name="originalContent" value="%-------------------------------------------------------------------------------&#10;% CONFIGURATION&#10;%-------------------------------------------------------------------------------&#10;&#10;\documentclass[11pt, a4paper]{russell}&#10;&#10;\usepackage{xcolor}&#10;&#10;\geometry{left=1.4cm, top=.8cm, right=1.4cm, bottom=1.8cm, footskip=.5cm}&#10;&#10;\fontdir[fonts/]&#10;&#10;\colorlet{russell}{russell-black}&#10;&#10;\setbool{acvSectionColorHighlight}{true}&#10;&#10;\renewcommand{\acvHeaderSocialSep}{\quad\textbar\quad}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% PERSONAL INFORMATION&#10;%-------------------------------------------------------------------------------&#10;&#10;\name{Victor Augusto}{Tramontina}&#10;&#10;\position{Computer Engineering -- \textbf{Full Stack Developer}}&#10;&#10;\mobile{+55 (54) 9 9937-7877}&#10;&#10;\email{victor.tramontina@universo.univates.br}&#10;&#10;\github{https://github.com/VicTramontina}&#10;&#10;% \linkedin{linkedin.com/in/victor-augusto-tramontina-ba3b26299}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;\begin{document}&#10;&#10;    \makecvheader&#10;&#10;    \makecvfooter{}{Victor Augusto Tramontina}{\thepage}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% SUMMARY&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{About Me}&#10;&#10;    \begin{cvparagraph}&#10;        \textbf{Motivated and collaborative full stack developer} with strong problem-solving skills and a solid background in \textbf{backend (Vanilla PHP, SQL)} and \textbf{modern frontend (ReactJS, TailwindCSS, Styled Components)}. Experienced in maintaining legacy systems, refactoring architectures, and integrating \textbf{cloud services (AWS)} and third-party APIs (OAuth2). Frequently leverages \textbf{AI tools and assistants} to support coding, debugging, and technical decision-making. Enthusiastic about learning and sharing knowledge, with an active role in \textbf{team discussions and technology decisions}.&#10;    \end{cvparagraph}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% SKILLS&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Skills}&#10;&#10;    \begin{cvskills}&#10;        \cvskill{Frontend}{ReactJS, TailwindCSS, Styled Components, React Hook Form, Zod}&#10;        \cvskill{Backend}{Vanilla PHP, Node, SQL, REST APIs, OAuth2}&#10;        \cvskill{DevOps \&amp; Tools}{Docker, Git, AWS (EC2, S3, Lambda, Cognito, Amplify), Linux, Crontabs}&#10;        \cvskill{Mobile}{React Native, Java, Android Studio, SQLite}&#10;        \cvskill{Integration}{Payment gateways, ERP platforms, Notifications and e-mail systems}&#10;    \end{cvskills}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% EXPERIENCE&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Professional Experience}&#10;&#10;    \begin{cventries}&#10;        \cventry&#10;        {\textbf{Full Stack Developer}}&#10;        {Macro Publicidade -- Conecta Venda System}&#10;        {Brazil}&#10;        {2022 -- Present}&#10;        {&#10;            \begin{cvitems}&#10;                \item {Worked in a \textbf{small agile team} (5 members) using \textbf{Scrum methodology}.}&#10;                \item {Maintained \textbf{legacy PHP systems} and refactored old AngularJS frontends into \textbf{ReactJS}.}&#10;                \item {Helped architect and implement \textbf{system-wide improvements} in frontend and database models.}&#10;                \item {Developed \textbf{reusable frontend components} and backend utilities to streamline workflows.}&#10;                \item {Participated in \textbf{technical decision-making}, mentoring junior teammates, and improving team practices.}&#10;                \item {Integrated external services using \textbf{OAuth2}, including payment gateways and ERP systems.}&#10;                \item {Handled \textbf{deployments and environment management} using Docker and AWS.}&#10;                \item {Contributed to the digital transformation of the company's systems, improving maintainability and scalability.}&#10;            \end{cvitems}&#10;        }&#10;    \end{cventries}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% PROJECTS&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Personal Projects}&#10;&#10;    \begin{cventries}&#10;        \cventry&#10;        {Guaporé - RS}&#10;        {Android Ticketing System}&#10;        {2023}&#10;        {}&#10;        {&#10;            \begin{cvitems}&#10;                \item {Developed a \textbf{complete Android app} for ticket printing and bar sales management.}&#10;                \item {Implemented product registration, order creation and report exports.}&#10;                \item {System is used by \textbf{over 8 companies} in the city.}&#10;                \item {Technologies used: \textbf{Java, Android Studio, SQLite, Epson SDK}.}&#10;            \end{cvitems}&#10;        }&#10;    \end{cventries}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% EDUCATION&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Education}&#10;&#10;    \begin{cventries}&#10;        \cventry&#10;        {Computer Engineering}&#10;        {Univates}&#10;        {Brazil}&#10;        {2022 -- Present, \textbf{7th Semester}}&#10;        {}&#10;    \end{cventries}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% LANGUAGES&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Languages}&#10;&#10;    \begin{cvskills}&#10;        \cvskill{Portuguese}{\textbf{Native}}&#10;        \cvskill{English}{\textbf{Advanced}}&#10;    \end{cvskills}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;\end{document}&#10;" />
              <option name="updatedContent" value="%-------------------------------------------------------------------------------&#10;% CONFIGURATION&#10;%-------------------------------------------------------------------------------&#10;&#10;\documentclass[11pt, a4paper]{russell}&#10;&#10;\usepackage{xcolor}&#10;&#10;\geometry{left=1.4cm, top=.8cm, right=1.4cm, bottom=1.8cm, footskip=.5cm}&#10;&#10;\fontdir[fonts/]&#10;&#10;\colorlet{russell}{russell-black}&#10;&#10;\setbool{acvSectionColorHighlight}{true}&#10;&#10;\renewcommand{\acvHeaderSocialSep}{\quad\textbar\quad}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% PERSONAL INFORMATION&#10;%-------------------------------------------------------------------------------&#10;&#10;\name{Victor Augusto}{Tramontina}&#10;&#10;\position{Computer Engineering -- \textbf{Full Stack Developer}}&#10;&#10;\mobile{+55 (54) 9 9937-7877}&#10;&#10;\email{victor.tramontina@universo.univates.br}&#10;&#10;\github{https://github.com/VicTramontina}&#10;&#10;% \linkedin{linkedin.com/in/victor-augusto-tramontina-ba3b26299}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;\begin{document}&#10;&#10;\makecvheader&#10;\makecvfooter{}{Victor Augusto Tramontina}{\thepage}&#10;&#10;%-------------------------------------------------------------------------------&#10;% SUMMARY&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{About Me}&#10;&#10;    \begin{cvparagraph}&#10;        \textbf{Motivated and collaborative full stack developer} with strong problem-solving skills and a solid background in \textbf{backend (Vanilla PHP, SQL)} and \textbf{modern frontend (ReactJS, TailwindCSS, Styled Components)}. Experienced in maintaining legacy systems, refactoring architectures, and integrating \textbf{cloud services (AWS)} and third-party APIs (OAuth2). Frequently leverages \textbf{AI tools and assistants} to support coding, debugging, and technical decision-making. Enthusiastic about learning and sharing knowledge, with an active role in \textbf{team discussions and technology decisions}.&#10;    \end{cvparagraph}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% SKILLS&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Skills}&#10;&#10;    \begin{cvskills}&#10;        \cvskill{Frontend}{ReactJS, TailwindCSS, Styled Components, React Hook Form, Zod}&#10;        \cvskill{Backend}{Vanilla PHP, Node, SQL, REST APIs, OAuth2}&#10;        \cvskill{DevOps \&amp; Tools}{Docker, Git, AWS (EC2, S3, Lambda, Cognito, Amplify), Linux, Crontabs}&#10;        \cvskill{Mobile}{React Native, Java, Android Studio, SQLite}&#10;        \cvskill{Integration}{Payment gateways, ERP platforms, Notifications and e-mail systems}&#10;    \end{cvskills}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% EXPERIENCE&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Professional Experience}&#10;&#10;    \begin{cventries}&#10;        \cventry&#10;        {\textbf{Full Stack Developer}}&#10;        {Macro Publicidade -- Conecta Venda System}&#10;        {Brazil}&#10;        {2022 -- Present}&#10;        {&#10;            \begin{cvitems}&#10;                \item {Worked in a \textbf{small agile team} (5 members) using \textbf{Scrum methodology}.}&#10;                \item {Maintained \textbf{legacy PHP systems} and refactored old AngularJS frontends into \textbf{ReactJS}.}&#10;                \item {Helped architect and implement \textbf{system-wide improvements} in frontend and database models.}&#10;                \item {Developed \textbf{reusable frontend components} and backend utilities to streamline workflows.}&#10;                \item {Participated in \textbf{technical decision-making}, mentoring junior teammates, and improving team practices.}&#10;                \item {Integrated external services using \textbf{OAuth2}, including payment gateways and ERP systems.}&#10;                \item {Handled \textbf{deployments and environment management} using Docker and AWS.}&#10;                \item {Contributed to the digital transformation of the company's systems, improving maintainability and scalability.}&#10;            \end{cvitems}&#10;        }&#10;    \end{cventries}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% PROJECTS&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Personal Projects}&#10;&#10;    \begin{cventries}&#10;        \cventry&#10;        {Guaporé - RS}&#10;        {Android Ticketing System}&#10;        {2023}&#10;        {}&#10;        {&#10;            \begin{cvitems}&#10;                \item {Developed a \textbf{complete Android app} for ticket printing and bar sales management.}&#10;                \item {Implemented product registration, order creation and report exports.}&#10;                \item {System is used by \textbf{over 8 companies} in the city.}&#10;                \item {Technologies used: \textbf{Java, Android Studio, SQLite, Epson SDK}.}&#10;            \end{cvitems}&#10;        }&#10;    \end{cventries}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% EDUCATION&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Education}&#10;&#10;    \begin{cventries}&#10;        \cventry&#10;        {Computer Engineering}&#10;        {Univates}&#10;        {Brazil}&#10;        {2022 -- Present, \textbf{7th Semester}}&#10;        {}&#10;    \end{cventries}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;% LANGUAGES&#10;%-------------------------------------------------------------------------------&#10;&#10;    \cvsection{Languages}&#10;&#10;    \begin{cvskills}&#10;        \cvskill{Portuguese}{\textbf{Native}}&#10;        \cvskill{English}{\textbf{Advanced}}&#10;    \end{cvskills}&#10;&#10;&#10;%-------------------------------------------------------------------------------&#10;\end{document}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/build_resume.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/build_resume.py" />
              <option name="originalContent" value="&quot;&quot;&quot;Utilities for building LaTeX resumes into PDF files.&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;import shutil&#10;import subprocess&#10;from pathlib import Path&#10;from typing import Dict, Any&#10;&#10;&#10;LATEX_SRC = Path(__file__).resolve().parents[1] / &quot;latex&quot;&#10;&#10;&#10;def prepare_job_directory(job_dir: Path) -&gt; None:&#10;    &quot;&quot;&quot;Copy the LaTeX source tree into *job_dir*.&#10;&#10;    The directory will contain a full copy of the ``latex`` folder so the&#10;    generated resume can be compiled in isolation.&#10;    &quot;&quot;&quot;&#10;    if job_dir.exists():&#10;        shutil.rmtree(job_dir)&#10;    shutil.copytree(LATEX_SRC, job_dir)&#10;&#10;&#10;def write_job_summary(job: Dict[str, Any], job_dir: Path) -&gt; None:&#10;    &quot;&quot;&quot;Create a markdown file summarising the job posting.&quot;&quot;&quot;&#10;    lines = [f&quot;# {job.get('title', 'Job')}\n&quot;]&#10;    for key, value in job.items():&#10;        if key == &quot;title&quot;:&#10;            continue&#10;        lines.append(f&quot;**{key.capitalize()}:** {value}\n&quot;)&#10;    (job_dir / &quot;job.md&quot;).write_text(&quot;\n&quot;.join(lines), encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def compile_pdf(job_dir: Path) -&gt; None:&#10;    &quot;&quot;&quot;Compile ``resume.tex`` inside *job_dir* using ``xelatex`` and ``biber``.&quot;&quot;&quot;&#10;    try:&#10;        # First XeLaTeX run&#10;        print(&quot;Running first XeLaTeX compilation...&quot;)&#10;        subprocess.run(&#10;            [&quot;xelatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;resume.tex&quot;],&#10;            cwd=job_dir,&#10;            check=False,  # Don't fail on warnings&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;&#10;        # Run Biber for bibliography processing&#10;        print(&quot;Running Biber for bibliography...&quot;)&#10;        subprocess.run(&#10;            [&quot;biber&quot;, &quot;resume&quot;],&#10;            cwd=job_dir,&#10;            check=False,  # Don't fail if no bibliography&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;&#10;        # Second XeLaTeX run to resolve references&#10;        print(&quot;Running second XeLaTeX compilation...&quot;)&#10;        result = subprocess.run(&#10;            [&quot;xelatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;resume.tex&quot;],&#10;            cwd=job_dir,&#10;            check=False,  # Don't fail on warnings&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;&#10;        # Check if PDF was actually created&#10;        pdf_file = job_dir / &quot;resume.pdf&quot;&#10;        if pdf_file.exists():&#10;            print(&quot;PDF compilation successful!&quot;)&#10;        else:&#10;            print(&quot;PDF compilation failed - no PDF file generated&quot;)&#10;            print(&quot;LaTeX output:&quot;)&#10;            print(result.stdout)&#10;            if result.stderr:&#10;                print(&quot;LaTeX stderr:&quot;)&#10;                print(result.stderr)&#10;            raise subprocess.CalledProcessError(result.returncode, result.args)&#10;&#10;    except subprocess.CalledProcessError as e:&#10;        print(f&quot;LaTeX compilation failed with return code {e.returncode}&quot;)&#10;        print(&quot;LaTeX output:&quot;)&#10;        print(e.stdout)&#10;        if e.stderr:&#10;            print(&quot;LaTeX stderr:&quot;)&#10;            print(e.stderr)&#10;        raise&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;Utilities for building LaTeX resumes into PDF files.&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;import shutil&#10;import subprocess&#10;from pathlib import Path&#10;from typing import Dict, Any&#10;&#10;&#10;LATEX_SRC = Path(__file__).resolve().parents[1] / &quot;latex&quot;&#10;&#10;&#10;def prepare_job_directory(job_dir: Path) -&gt; None:&#10;    &quot;&quot;&quot;Copy the LaTeX source tree into *job_dir*.&#10;&#10;    The directory will contain a full copy of the ``latex`` folder so the&#10;    generated resume can be compiled in isolation.&#10;    &quot;&quot;&quot;&#10;    print(f&quot; Preparing job directory: {job_dir}&quot;)&#10;    if job_dir.exists():&#10;        print(f&quot;️ Removing existing directory: {job_dir}&quot;)&#10;        shutil.rmtree(job_dir)&#10;    print(f&quot; Copying LaTeX source from {LATEX_SRC} to {job_dir}&quot;)&#10;    shutil.copytree(LATEX_SRC, job_dir)&#10;    print(f&quot;✅ Job directory prepared successfully&quot;)&#10;&#10;&#10;def write_job_summary(job: Dict[str, Any], job_dir: Path) -&gt; None:&#10;    &quot;&quot;&quot;Create a markdown file summarising the job posting.&quot;&quot;&quot;&#10;    print(f&quot; Writing job summary to {job_dir / 'job.md'}&quot;)&#10;    lines = [f&quot;# {job.get('title', 'Job')}\n&quot;]&#10;    for key, value in job.items():&#10;        if key == &quot;title&quot;:&#10;            continue&#10;        lines.append(f&quot;**{key.capitalize()}:** {value}\n&quot;)&#10;    (job_dir / &quot;job.md&quot;).write_text(&quot;\n&quot;.join(lines), encoding=&quot;utf-8&quot;)&#10;    print(f&quot;✅ Job summary written ({len(lines)} lines)&quot;)&#10;&#10;&#10;def compile_pdf(job_dir: Path) -&gt; None:&#10;    &quot;&quot;&quot;Compile ``resume.tex`` inside *job_dir* using ``xelatex`` and ``biber``.&quot;&quot;&quot;&#10;    print(f&quot; Starting PDF compilation in {job_dir}&quot;)&#10;    &#10;    try:&#10;        # First XeLaTeX run&#10;        print(&quot; Running first XeLaTeX compilation...&quot;)&#10;        result1 = subprocess.run(&#10;            [&quot;xelatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;resume.tex&quot;],&#10;            cwd=job_dir,&#10;            check=False,  # Don't fail on warnings&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;        print(f&quot; First XeLaTeX run completed (exit code: {result1.returncode})&quot;)&#10;        &#10;        # Run Biber for bibliography processing&#10;        print(&quot; Running Biber for bibliography processing...&quot;)&#10;        biber_result = subprocess.run(&#10;            [&quot;biber&quot;, &quot;resume&quot;],&#10;            cwd=job_dir,&#10;            check=False,  # Don't fail if no bibliography&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;        print(f&quot; Biber run completed (exit code: {biber_result.returncode})&quot;)&#10;        &#10;        # Second XeLaTeX run to resolve references&#10;        print(&quot; Running second XeLaTeX compilation...&quot;)&#10;        result2 = subprocess.run(&#10;            [&quot;xelatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;resume.tex&quot;],&#10;            cwd=job_dir,&#10;            check=False,  # Don't fail on warnings&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;        print(f&quot; Second XeLaTeX run completed (exit code: {result2.returncode})&quot;)&#10;        &#10;        # Check if PDF was actually created&#10;        pdf_file = job_dir / &quot;resume.pdf&quot;&#10;        if pdf_file.exists():&#10;            pdf_size = pdf_file.stat().st_size&#10;            print(f&quot;✅ PDF compilation successful! Generated file: {pdf_file} ({pdf_size} bytes)&quot;)&#10;        else:&#10;            print(&quot;❌ PDF compilation failed - no PDF file generated&quot;)&#10;            print(&quot; XeLaTeX output from final run:&quot;)&#10;            print(result2.stdout)&#10;            if result2.stderr:&#10;                print(&quot; XeLaTeX stderr:&quot;)&#10;                print(result2.stderr)&#10;            raise subprocess.CalledProcessError(result2.returncode, result2.args)&#10;            &#10;    except subprocess.CalledProcessError as e:&#10;        print(f&quot;❌ LaTeX compilation failed with return code {e.returncode}&quot;)&#10;        print(&quot; LaTeX output:&quot;)&#10;        print(e.stdout)&#10;        if e.stderr:&#10;            print(&quot; LaTeX stderr:&quot;)&#10;            print(e.stderr)&#10;        raise&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/gemini_api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/gemini_api.py" />
              <option name="originalContent" value="&quot;&quot;&quot;Interface with the Google Gemini API.&#10;&#10;The actual API key must be supplied in the environment variable&#10;``GEMINI_API_KEY``.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;import os&#10;import time&#10;from pathlib import Path&#10;from typing import Dict, Any&#10;&#10;import google.generativeai as genai&#10;from google.api_core.exceptions import ResourceExhausted&#10;&#10;&#10;def tailor_resume(job: Dict[str, Any], base_resume: str | Path) -&gt; str:&#10;    &quot;&quot;&quot;Return a resume tailored to *job*.&#10;&#10;    Parameters&#10;    ----------&#10;    job:&#10;        Dictionary with information about the job opening. The ``description``&#10;        field is particularly important.&#10;    base_resume:&#10;        Path to the base LaTeX resume used as a starting point.&#10;    &quot;&quot;&quot;&#10;    print(f&quot; Starting resume tailoring for job: {job.get('title', 'Unknown')}&quot;)&#10;&#10;    api_key = os.environ.get(&quot;GEMINI_API_KEY&quot;)&#10;    if not api_key:&#10;        raise RuntimeError(&quot;GEMINI_API_KEY environment variable not set&quot;)&#10;&#10;    print(&quot; Configuring Gemini API...&quot;)&#10;    genai.configure(api_key=api_key)&#10;    model = genai.GenerativeModel(&quot;gemini-1.5-flash&quot;)&#10;&#10;    print(&quot; Reading base resume template...&quot;)&#10;    base_resume = Path(base_resume).read_text(encoding=&quot;utf-8&quot;)&#10;    job_desc = job.get(&quot;description&quot;, &quot;&quot;)&#10;&#10;    print(f&quot; Job description length: {len(job_desc)} characters&quot;)&#10;    print(f&quot; Base resume length: {len(base_resume)} characters&quot;)&#10;&#10;    prompt = (&#10;        &quot;You are an assistant that customizes LaTeX resumes. Given the job &quot;&#10;        &quot;description and the base resume, rewrite the resume so that it &quot;&#10;        &quot;highlights the most relevant skills and experience for the job. &quot;&#10;        &quot;Make sure to keep the structure of the resume intact, &quot;&#10;        &quot;but modify the content to better match the job requirements. &quot;&#10;        &quot;Do not add any new sections or remove existing ones. &quot;&#10;        &quot;Focus on tailoring the content to the job description, &quot;&#10;        &quot;while preserving the original formatting and structure of the resume. &quot;&#10;        &quot;Return only valid LaTeX code.\n\n&quot;&#10;        f&quot;Job description:\n{job_desc}\n\n&quot;&#10;        f&quot;Base resume:\n{base_resume}\n&quot;&#10;    )&#10;&#10;    print(f&quot; Sending prompt to Gemini API (length: {len(prompt)} characters)...&quot;)&#10;&#10;    # Retry logic for rate limiting&#10;    max_retries = 3&#10;    base_delay = 60  # Start with 60 seconds delay&#10;&#10;    for attempt in range(max_retries):&#10;        try:&#10;            print(f&quot; API call attempt {attempt + 1}/{max_retries}...&quot;)&#10;            response = model.generate_content(prompt)&#10;            print(f&quot;✅ Successfully received response from Gemini API (length: {len(response.text)} characters)&quot;)&#10;            return response.text&#10;        except ResourceExhausted as e:&#10;            if attempt &lt; max_retries - 1:&#10;                # Extract retry delay from error if available, otherwise use exponential backoff&#10;                retry_delay = base_delay * (2 ** attempt)&#10;                print(f&quot;⚠️ Rate limit exceeded. Retrying in {retry_delay} seconds... (attempt {attempt + 1}/{max_retries})&quot;)&#10;                time.sleep(retry_delay)&#10;            else:&#10;                print(&quot;❌ Max retries exceeded. Please wait before running again or consider upgrading your API plan.&quot;)&#10;                raise&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;Interface with the Google Gemini API.&#10;&#10;The actual API key must be supplied in the environment variable&#10;``GEMINI_API_KEY``.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;import os&#10;import time&#10;from pathlib import Path&#10;from typing import Dict, Any&#10;&#10;import google.generativeai as genai&#10;from google.api_core.exceptions import ResourceExhausted&#10;&#10;&#10;def tailor_resume(job: Dict[str, Any], base_resume: str | Path) -&gt; str:&#10;    &quot;&quot;&quot;Return a resume tailored to *job*.&#10;&#10;    Parameters&#10;    ----------&#10;    job:&#10;        Dictionary with information about the job opening. The ``description``&#10;        field is particularly important.&#10;    base_resume:&#10;        Path to the base LaTeX resume used as a starting point.&#10;    &quot;&quot;&quot;&#10;    print(f&quot; Starting resume tailoring for job: {job.get('title', 'Unknown')}&quot;)&#10;&#10;    api_key = os.environ.get(&quot;GEMINI_API_KEY&quot;)&#10;    if not api_key:&#10;        raise RuntimeError(&quot;GEMINI_API_KEY environment variable not set&quot;)&#10;&#10;    print(&quot; Configuring Gemini API...&quot;)&#10;    genai.configure(api_key=api_key)&#10;    model = genai.GenerativeModel(&quot;gemini-1.5-flash&quot;)&#10;&#10;    print(&quot; Reading base resume template...&quot;)&#10;    base_resume = Path(base_resume).read_text(encoding=&quot;utf-8&quot;)&#10;    job_desc = job.get(&quot;description&quot;, &quot;&quot;)&#10;&#10;    print(f&quot; Job description length: {len(job_desc)} characters&quot;)&#10;    print(f&quot; Base resume length: {len(base_resume)} characters&quot;)&#10;&#10;    prompt = (&#10;        &quot;You are an assistant that customizes LaTeX resumes. Given the job &quot;&#10;        &quot;description and the base resume, rewrite the resume so that it &quot;&#10;        &quot;highlights the most relevant skills and experience for the job. &quot;&#10;        &quot;IMPORTANT FORMATTING RULES:\n&quot;&#10;        &quot;- Keep the EXACT structure and formatting of the original resume\n&quot;&#10;        &quot;- Do NOT add extra blank lines or indentation\n&quot;&#10;        &quot;- Do NOT reformat the LaTeX spacing\n&quot;&#10;        &quot;- Only modify the CONTENT within sections, not the structure\n&quot;&#10;        &quot;- Preserve the exact line breaks and spacing from the original\n&quot;&#10;        &quot;- Focus ONLY on tailoring the content to match the job requirements\n&quot;&#10;        &quot;Return only valid LaTeX code with the original formatting preserved.\n\n&quot;&#10;        f&quot;Job description:\n{job_desc}\n\n&quot;&#10;        f&quot;Base resume:\n{base_resume}\n&quot;&#10;    )&#10;&#10;    print(f&quot; Sending prompt to Gemini API (length: {len(prompt)} characters)...&quot;)&#10;&#10;    # Retry logic for rate limiting&#10;    max_retries = 3&#10;    base_delay = 60  # Start with 60 seconds delay&#10;&#10;    for attempt in range(max_retries):&#10;        try:&#10;            print(f&quot; API call attempt {attempt + 1}/{max_retries}...&quot;)&#10;            response = model.generate_content(prompt)&#10;            print(f&quot;✅ Successfully received response from Gemini API (length: {len(response.text)} characters)&quot;)&#10;            return response.text&#10;        except ResourceExhausted as e:&#10;            if attempt &lt; max_retries - 1:&#10;                # Extract retry delay from error if available, otherwise use exponential backoff&#10;                retry_delay = base_delay * (2 ** attempt)&#10;                print(f&quot;⚠️ Rate limit exceeded. Retrying in {retry_delay} seconds... (attempt {attempt + 1}/{max_retries})&quot;)&#10;                time.sleep(retry_delay)&#10;            else:&#10;                print(&quot;❌ Max retries exceeded. Please wait before running again or consider upgrading your API plan.&quot;)&#10;                raise" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/main.py" />
              <option name="originalContent" value="&quot;&quot;&quot;End-to-end pipeline for generating tailored resumes.&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from pathlib import Path&#10;&#10;from scrape_jobs import scrape_jobs&#10;from gemini_api import tailor_resume&#10;from build_resume import prepare_job_directory, write_job_summary, compile_pdf&#10;&#10;CONFIG_PATH = Path(__file__).resolve().parents[1] / &quot;config&quot; / &quot;job_config.yaml&quot;&#10;OUTPUT_ROOT = Path(__file__).resolve().parents[1] / &quot;outputs&quot;&#10;&#10;&#10;def generate_resumes(config_path: Path = CONFIG_PATH, output_root: Path = OUTPUT_ROOT) -&gt; None:&#10;    jobs = scrape_jobs(config_path)&#10;    output_root.mkdir(exist_ok=True)&#10;&#10;    for idx, job in enumerate(jobs, 1):&#10;        job_dir = output_root / f&quot;job_{idx}&quot;&#10;        prepare_job_directory(job_dir)&#10;        write_job_summary(job, job_dir)&#10;        tailored = tailor_resume(job, job_dir / &quot;resume.tex&quot;)&#10;        (job_dir / &quot;resume.tex&quot;).write_text(tailored, encoding=&quot;utf-8&quot;)&#10;        compile_pdf(job_dir)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    generate_resumes()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;End-to-end pipeline for generating tailored resumes.&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;import time&#10;from pathlib import Path&#10;&#10;from scrape_jobs import scrape_jobs&#10;from gemini_api import tailor_resume&#10;from build_resume import prepare_job_directory, write_job_summary, compile_pdf&#10;&#10;CONFIG_PATH = Path(__file__).resolve().parents[1] / &quot;config&quot; / &quot;job_config.yaml&quot;&#10;OUTPUT_ROOT = Path(__file__).resolve().parents[1] / &quot;outputs&quot;&#10;&#10;&#10;def generate_resumes(config_path: Path = CONFIG_PATH, output_root: Path = OUTPUT_ROOT) -&gt; None:&#10;    print(&quot; Starting resume generation pipeline...&quot;)&#10;    print(f&quot; Config file: {config_path}&quot;)&#10;    print(f&quot; Output directory: {output_root}&quot;)&#10;    &#10;    start_time = time.time()&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot;*60)&#10;    print(&quot; PHASE 1: JOB SCRAPING&quot;)&#10;    print(&quot;=&quot;*60)&#10;    &#10;    jobs = scrape_jobs(config_path)&#10;    print(f&quot;\n✅ Job scraping completed! Found {len(jobs)} jobs to process&quot;)&#10;    &#10;    if not jobs:&#10;        print(&quot;⚠️ No jobs found. Exiting...&quot;)&#10;        return&#10;    &#10;    print(f&quot;\n Creating output directory: {output_root}&quot;)&#10;    output_root.mkdir(exist_ok=True)&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot;*60)&#10;    print(&quot; PHASE 2: RESUME GENERATION&quot;)&#10;    print(&quot;=&quot;*60)&#10;    &#10;    for idx, job in enumerate(jobs, 1):&#10;        print(f&quot;\n Processing job {idx}/{len(jobs)}: {job.get('title', 'Unknown')}&quot;)&#10;        print(f&quot; Company: {job.get('company', 'Unknown')}&quot;)&#10;        print(f&quot; Location: {job.get('location', 'Unknown')}&quot;)&#10;        &#10;        job_start_time = time.time()&#10;        job_dir = output_root / f&quot;job_{idx}&quot;&#10;        &#10;        # Step 1: Prepare directory&#10;        print(f&quot;\n Step 1/5: Preparing job directory...&quot;)&#10;        prepare_job_directory(job_dir)&#10;        &#10;        # Step 2: Write job summary&#10;        print(f&quot; Step 2/5: Writing job summary...&quot;)&#10;        write_job_summary(job, job_dir)&#10;        &#10;        # Step 3: Tailor resume with AI&#10;        print(f&quot; Step 3/5: Tailoring resume with AI...&quot;)&#10;        tailored = tailor_resume(job, job_dir / &quot;resume.tex&quot;)&#10;        &#10;        # Step 4: Save tailored resume&#10;        print(f&quot; Step 4/5: Saving tailored resume...&quot;)&#10;        tailored_file = job_dir / &quot;resume.tex&quot;&#10;        tailored_file.write_text(tailored, encoding=&quot;utf-8&quot;)&#10;        print(f&quot; Tailored resume saved to: {tailored_file}&quot;)&#10;        &#10;        # Step 5: Compile PDF&#10;        print(f&quot; Step 5/5: Compiling PDF...&quot;)&#10;        compile_pdf(job_dir)&#10;        &#10;        job_duration = time.time() - job_start_time&#10;        print(f&quot;✅ Job {idx} completed in {job_duration:.2f} seconds&quot;)&#10;        &#10;        # Add a small delay between jobs to respect API limits&#10;        if idx &lt; len(jobs):&#10;            print(&quot;⏳ Waiting 5 seconds before next job...&quot;)&#10;            time.sleep(5)&#10;    &#10;    total_duration = time.time() - start_time&#10;    print(&quot;\n&quot; + &quot;=&quot;*60)&#10;    print(&quot; PIPELINE COMPLETED!&quot;)&#10;    print(&quot;=&quot;*60)&#10;    print(f&quot; Total jobs processed: {len(jobs)}&quot;)&#10;    print(f&quot;⏱️ Total time: {total_duration:.2f} seconds&quot;)&#10;    print(f&quot; Output location: {output_root}&quot;)&#10;    print(&quot;=&quot;*60)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    generate_resumes()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_skills.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_skills.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&#10;import sys&#10;sys.path.append('/home/victor/webpages/curriculo/scripts')&#10;&#10;from scrape_jobs import _check_skills_match&#10;&#10;# Teste da nova funcionalidade de skills obrigatórias/opcionais&#10;def test_skills_logic():&#10;    print(&quot;=== Testando Lógica de Skills ===&quot;)&#10;    &#10;    # Configuração de exemplo&#10;    skills_config = [&#10;        {&quot;name&quot;: &quot;Python&quot;, &quot;required&quot;: True},&#10;        {&quot;name&quot;: &quot;SQL&quot;, &quot;required&quot;: True},&#10;        {&quot;name&quot;: &quot;Docker&quot;, &quot;required&quot;: False},&#10;        {&quot;name&quot;: &quot;React&quot;, &quot;required&quot;: False},&#10;        &quot;Git&quot;,  # Formato antigo (opcional)&#10;        &quot;Linux&quot;&#10;    ]&#10;    &#10;    # Teste 1: Vaga que tem skills obrigatórias&#10;    job_text1 = &quot;Desenvolvedor Python com conhecimento em SQL e bancos de dados&quot;&#10;    result1 = _check_skills_match(job_text1, skills_config)&#10;    print(f&quot;Teste 1 - Vaga com Python e SQL: {result1} ✓&quot;)&#10;    &#10;    # Teste 2: Vaga que não tem skills obrigatórias &#10;    job_text2 = &quot;Desenvolvedor JavaScript com React e Docker&quot;&#10;    result2 = _check_skills_match(job_text2, skills_config)&#10;    print(f&quot;Teste 2 - Vaga sem Python/SQL: {result2} ✗&quot;)&#10;    &#10;    # Teste 3: Vaga com apenas uma skill obrigatória&#10;    job_text3 = &quot;Programador Python para desenvolvimento web&quot;&#10;    result3 = _check_skills_match(job_text3, skills_config)&#10;    print(f&quot;Teste 3 - Vaga só com Python: {result3} ✗&quot;)&#10;    &#10;    # Teste 4: Vaga com skills obrigatórias + opcionais&#10;    job_text4 = &quot;Desenvolvedor Python e SQL com experiência em Git&quot;&#10;    result4 = _check_skills_match(job_text4, skills_config)&#10;    print(f&quot;Teste 4 - Vaga com obrigatórias + Git: {result4} ✓&quot;)&#10;    &#10;    print(&quot;\n=== Resumo ===&quot;)&#10;    print(&quot;- Para passar no filtro, a vaga DEVE conter TODAS as skills obrigatórias&quot;)&#10;    print(&quot;- Skills opcionais servem como bônus, mas não são suficientes sozinhas&quot;)&#10;    print(&quot;- Formato antigo (string simples) continua funcionando como opcional&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_skills_logic()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>